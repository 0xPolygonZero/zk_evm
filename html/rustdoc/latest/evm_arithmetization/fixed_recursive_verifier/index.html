<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `fixed_recursive_verifier` mod in crate `evm_arithmetization`."><title>evm_arithmetization::fixed_recursive_verifier - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="evm_arithmetization" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (1f12b9b0f 2024-08-27)" data-channel="nightly" data-search-js="search-acd2e111c9cb27e3.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
    integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
    integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            fleqn: false,
            macros: {
                "\\F": "\\mathbb{F}",
                "\\G": "\\mathbb{G}",
                "\\O": "\\mathcal{O}",
                "\\(": "\\left(",
                "\\)": "\\right)",
                "\\norm": "\\left\\vert #1 \\right\\vert",
                "\\set": "\\mathcal{ #1 }",
            },
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\(", right: "\\)", display: false },
                { left: "$", right: "$", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    });
</script>
</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../evm_arithmetization/index.html">evm_<wbr>arithmetization</a><span class="version">0.4.0</span></h2></div><h2 class="location"><a href="#">Module fixed_<wbr>recursive_<wbr>verifier</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate evm_<wbr>arithmetization</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">evm_arithmetization</a>::<wbr><a class="mod" href="#">fixed_recursive_verifier</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1-2699">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursive<wbr>Circuits</a></div><div class="desc docblock-short">Contains all recursive circuits used in the system. For each STARK and each
initial <code>degree_bits</code>, this contains a chain of recursive circuits for
shrinking that STARK from <code>degree_bits</code> to a constant
<code>THRESHOLD_DEGREE_BITS</code>. It also contains a special root circuit
for combining each STARK’s shrunk wrapper proof into a single proof.</div></li><li><div class="item-name"><a class="struct" href="struct.BlockCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::BlockCircuitData">Block<wbr>Circuit<wbr>Data</a></div><div class="desc docblock-short">Data for the block circuit, which is used to generate a final block proof,
and compress it with an optional parent proof if present.</div></li><li><div class="item-name"><a class="struct" href="struct.ProverOutputData.html" title="struct evm_arithmetization::fixed_recursive_verifier::ProverOutputData">Prover<wbr>Output<wbr>Data</a></div></li><li><div class="item-name"><a class="struct" href="struct.RecursiveCircuitsForTable.html" title="struct evm_arithmetization::fixed_recursive_verifier::RecursiveCircuitsForTable">Recursive<wbr>Circuits<wbr>ForTable</a></div><div class="desc docblock-short">A map between initial degree sizes and their associated shrinking recursion
circuits.</div></li><li><div class="item-name"><a class="struct" href="struct.RecursiveCircuitsForTableSize.html" title="struct evm_arithmetization::fixed_recursive_verifier::RecursiveCircuitsForTableSize">Recursive<wbr>Circuits<wbr>ForTable<wbr>Size</a></div><div class="desc docblock-short">A chain of shrinking wrapper circuits, ending with a final circuit with
<code>degree_bits</code> <code>THRESHOLD_DEGREE_BITS</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.RootCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::RootCircuitData">Root<wbr>Circuit<wbr>Data</a></div><div class="desc docblock-short">Data for the EVM root circuit, which is used to combine each STARK’s shrunk
wrapper proof into a single proof.</div></li><li><div class="item-name"><a class="struct" href="struct.SegmentAggregationCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::SegmentAggregationCircuitData">Segment<wbr>Aggregation<wbr>Circuit<wbr>Data</a></div><div class="desc docblock-short">Data for the segment aggregation circuit, which is used to compress two
segment proofs into one. Each inner proof can be either an EVM root proof or
another segment aggregation proof.</div></li><li><div class="item-name"><a class="struct" href="struct.TwoToOneBlockCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::TwoToOneBlockCircuitData">TwoTo<wbr>OneBlock<wbr>Circuit<wbr>Data</a></div><div class="desc docblock-short">Data for the two-to-one block circuit, which is used to generate a
proof of two unrelated proofs.</div></li><li><div class="item-name"><a class="struct" href="struct.TxnAggregationCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::TxnAggregationCircuitData">TxnAggregation<wbr>Circuit<wbr>Data</a></div><div class="desc docblock-short">Data for the transaction aggregation circuit, which is used to compress two
proofs into one. Each inner proof can be either a segment aggregation proof
or another transaction aggregation proof.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.extract_block_public_values.html" title="fn evm_arithmetization::fixed_recursive_verifier::extract_block_public_values">extract_<wbr>block_<wbr>public_<wbr>values</a></div><div class="desc docblock-short">Extracts the two-to-one block aggregation public values of the block from
a public inputs slice.</div></li><li><div class="item-name"><a class="fn" href="fn.extract_two_to_one_block_hash.html" title="fn evm_arithmetization::fixed_recursive_verifier::extract_two_to_one_block_hash">extract_<wbr>two_<wbr>to_<wbr>one_<wbr>block_<wbr>hash</a></div><div class="desc docblock-short">Extracts the two-to-one block aggregation hash from a public inputs slice.</div></li><li><div class="item-name"><a class="fn" href="fn.verification_key_len.html" title="fn evm_arithmetization::fixed_recursive_verifier::verification_key_len">verification_<wbr>key_<wbr>len</a></div><div class="desc docblock-short">Computes the length added to the public inputs vector by
[<code>CircuitBuilder::add_verifier_data_public_inputs</code>].</div></li></ul></section></div></main></body></html>