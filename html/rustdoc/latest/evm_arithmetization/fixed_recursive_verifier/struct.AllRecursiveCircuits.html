<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Contains all recursive circuits used in the system. For each STARK and each initial `degree_bits`, this contains a chain of recursive circuits for shrinking that STARK from `degree_bits` to a constant `THRESHOLD_DEGREE_BITS`. It also contains a special root circuit for combining each STARK’s shrunk wrapper proof into a single proof."><title>AllRecursiveCircuits in evm_arithmetization::fixed_recursive_verifier - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="evm_arithmetization" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (1f12b9b0f 2024-08-27)" data-channel="nightly" data-search-js="search-acd2e111c9cb27e3.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
    integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
    integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            fleqn: false,
            macros: {
                "\\F": "\\mathbb{F}",
                "\\G": "\\mathbb{G}",
                "\\O": "\\mathcal{O}",
                "\\(": "\\left(",
                "\\)": "\\right)",
                "\\norm": "\\left\\vert #1 \\right\\vert",
                "\\set": "\\mathcal{ #1 }",
            },
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\(", right: "\\)", display: false },
                { left: "$", right: "$", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    });
</script>
</head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../evm_arithmetization/index.html">evm_<wbr>arithmetization</a><span class="version">0.4.0</span></h2></div><h2 class="location"><a href="#">AllRecursive<wbr>Circuits</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.block">block</a></li><li><a href="#structfield.by_table">by_table</a></li><li><a href="#structfield.root">root</a></li><li><a href="#structfield.segment_aggregation">segment_aggregation</a></li><li><a href="#structfield.two_to_one_block">two_to_one_block</a></li><li><a href="#structfield.txn_aggregation">txn_aggregation</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.final_verifier_data">final_verifier_data</a></li><li><a href="#method.from_bytes">from_bytes</a></li><li><a href="#method.new">new</a></li><li><a href="#method.prove_all_segments">prove_all_segments</a></li><li><a href="#method.prove_block">prove_block</a></li><li><a href="#method.prove_segment">prove_segment</a></li><li><a href="#method.prove_segment_after_initial_stark">prove_segment_after_initial_stark</a></li><li><a href="#method.prove_segment_aggregation">prove_segment_aggregation</a></li><li><a href="#method.prove_transaction_aggregation">prove_transaction_aggregation</a></li><li><a href="#method.prove_two_to_one_block">prove_two_to_one_block</a></li><li><a href="#method.to_bytes">to_bytes</a></li><li><a href="#method.verify_block">verify_block</a></li><li><a href="#method.verify_root">verify_root</a></li><li><a href="#method.verify_segment_aggregation">verify_segment_aggregation</a></li><li><a href="#method.verify_two_to_one_block">verify_two_to_one_block</a></li><li><a href="#method.verify_txn_aggregation">verify_txn_aggregation</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-AllRecursiveCircuits%3CF,+C,+D%3E">Debug</a></li><li><a href="#impl-Eq-for-AllRecursiveCircuits%3CF,+C,+D%3E">Eq</a></li><li><a href="#impl-PartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-AllRecursiveCircuits%3CF,+C,+D%3E">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-AllRecursiveCircuits%3CF,+C,+D%3E">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-AllRecursiveCircuits%3CF,+C,+D%3E">Freeze</a></li><li><a href="#impl-Send-for-AllRecursiveCircuits%3CF,+C,+D%3E">Send</a></li><li><a href="#impl-Sync-for-AllRecursiveCircuits%3CF,+C,+D%3E">Sync</a></li><li><a href="#impl-Unpin-for-AllRecursiveCircuits%3CF,+C,+D%3E">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q">Equivalent&#60;K&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T">IntoEither</a></li><li><a href="#impl-Pointable-for-T">Pointable</a></li><li><a href="#impl-Same-for-T">Same</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T">VZip&#60;V&#62;</a></li></ul></section><h2><a href="index.html">In evm_<wbr>arithmetization::<wbr>fixed_<wbr>recursive_<wbr>verifier</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">evm_arithmetization</a>::<wbr><a href="index.html">fixed_recursive_verifier</a>::<wbr><a class="struct" href="#">AllRecursiveCircuits</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#79-104">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct AllRecursiveCircuits&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;<div class="where">where
    F: RichField + Extendable&lt;D&gt;,
    C: GenericConfig&lt;D, F = F&gt;,
    C::Hasher: AlgebraicHasher&lt;F&gt;,</div>{
    pub root: <a class="struct" href="struct.RootCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::RootCircuitData">RootCircuitData</a>&lt;F, C, D&gt;,
    pub segment_aggregation: <a class="struct" href="struct.SegmentAggregationCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::SegmentAggregationCircuitData">SegmentAggregationCircuitData</a>&lt;F, C, D&gt;,
    pub txn_aggregation: <a class="struct" href="struct.TxnAggregationCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::TxnAggregationCircuitData">TxnAggregationCircuitData</a>&lt;F, C, D&gt;,
    pub block: <a class="struct" href="struct.BlockCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::BlockCircuitData">BlockCircuitData</a>&lt;F, C, D&gt;,
    pub two_to_one_block: <a class="struct" href="struct.TwoToOneBlockCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::TwoToOneBlockCircuitData">TwoToOneBlockCircuitData</a>&lt;F, C, D&gt;,
    pub by_table: [<a class="struct" href="struct.RecursiveCircuitsForTable.html" title="struct evm_arithmetization::fixed_recursive_verifier::RecursiveCircuitsForTable">RecursiveCircuitsForTable</a>&lt;F, C, D&gt;; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">9</a>],
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Contains all recursive circuits used in the system. For each STARK and each
initial <code>degree_bits</code>, this contains a chain of recursive circuits for
shrinking that STARK from <code>degree_bits</code> to a constant
<code>THRESHOLD_DEGREE_BITS</code>. It also contains a special root circuit
for combining each STARK’s shrunk wrapper proof into a single proof.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.root" class="structfield section-header"><a href="#structfield.root" class="anchor field">§</a><code>root: <a class="struct" href="struct.RootCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::RootCircuitData">RootCircuitData</a>&lt;F, C, D&gt;</code></span><div class="docblock"><p>The EVM root circuit, which aggregates the (shrunk) per-table recursive
proofs.</p>
</div><span id="structfield.segment_aggregation" class="structfield section-header"><a href="#structfield.segment_aggregation" class="anchor field">§</a><code>segment_aggregation: <a class="struct" href="struct.SegmentAggregationCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::SegmentAggregationCircuitData">SegmentAggregationCircuitData</a>&lt;F, C, D&gt;</code></span><div class="docblock"><p>The segment aggregation circuit, which verifies that two segment proofs
that can either be root or aggregation proofs.</p>
</div><span id="structfield.txn_aggregation" class="structfield section-header"><a href="#structfield.txn_aggregation" class="anchor field">§</a><code>txn_aggregation: <a class="struct" href="struct.TxnAggregationCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::TxnAggregationCircuitData">TxnAggregationCircuitData</a>&lt;F, C, D&gt;</code></span><div class="docblock"><p>The transaction aggregation circuit, which verifies the aggregation of
two proofs that can either be a segment aggregation representing a
transaction or an aggregation of transactions.</p>
</div><span id="structfield.block" class="structfield section-header"><a href="#structfield.block" class="anchor field">§</a><code>block: <a class="struct" href="struct.BlockCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::BlockCircuitData">BlockCircuitData</a>&lt;F, C, D&gt;</code></span><div class="docblock"><p>The block circuit, which verifies a transaction aggregation proof and an
optional previous block proof.</p>
</div><span id="structfield.two_to_one_block" class="structfield section-header"><a href="#structfield.two_to_one_block" class="anchor field">§</a><code>two_to_one_block: <a class="struct" href="struct.TwoToOneBlockCircuitData.html" title="struct evm_arithmetization::fixed_recursive_verifier::TwoToOneBlockCircuitData">TwoToOneBlockCircuitData</a>&lt;F, C, D&gt;</code></span><div class="docblock"><p>The two-to-one block aggregation circuit, which verifies two unrelated
block proofs.</p>
</div><span id="structfield.by_table" class="structfield section-header"><a href="#structfield.by_table" class="anchor field">§</a><code>by_table: [<a class="struct" href="struct.RecursiveCircuitsForTable.html" title="struct evm_arithmetization::fixed_recursive_verifier::RecursiveCircuitsForTable">RecursiveCircuitsForTable</a>&lt;F, C, D&gt;; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">9</a>]</code></span><div class="docblock"><p>Holds chains of circuits for each table and for each initial
<code>degree_bits</code>.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#487-2387">source</a><a href="#impl-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    F: RichField + Extendable&lt;D&gt;,
    C: GenericConfig&lt;D, F = F&gt; + 'static,
    C::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_bytes" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#504-529">source</a><h4 class="code-header">pub fn <a href="#method.to_bytes" class="fn">to_bytes</a>(
    &amp;self,
    skip_tables: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    gate_serializer: &amp;dyn GateSerializer&lt;F, D&gt;,
    generator_serializer: &amp;dyn WitnessGeneratorSerializer&lt;F, D&gt;,
) -&gt; IoResult&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Serializes all these preprocessed circuits into a sequence of bytes.</p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h5>
<ul>
<li><code>skip_tables</code>: a boolean indicating whether to serialize only the
upper circuits or the entire prover state, including recursive
circuits to shrink STARK proofs.</li>
<li><code>gate_serializer</code>: a custom gate serializer needed to serialize
recursive circuits common data.</li>
<li><code>generator_serializer</code>: a custom generator serializer needed to
serialize recursive circuits proving data.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bytes" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#544-609">source</a><h4 class="code-header">pub fn <a href="#method.from_bytes" class="fn">from_bytes</a>(
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
    skip_tables: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    gate_serializer: &amp;dyn GateSerializer&lt;F, D&gt;,
    generator_serializer: &amp;dyn WitnessGeneratorSerializer&lt;F, D&gt;,
) -&gt; IoResult&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Deserializes a sequence of bytes into an entire prover state containing
all recursive circuits.</p>
<h5 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h5>
<ul>
<li><code>bytes</code>: a slice of bytes to deserialize this prover state from.</li>
<li><code>skip_tables</code>: a boolean indicating whether to deserialize only the
upper circuits or the entire prover state, including recursive
circuits to shrink STARK proofs.</li>
<li><code>gate_serializer</code>: a custom gate serializer needed to serialize
recursive circuits common data.</li>
<li><code>generator_serializer</code>: a custom generator serializer needed to
serialize recursive circuits proving data.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#629-726">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(
    all_stark: &amp;<a class="struct" href="../all_stark/struct.AllStark.html" title="struct evm_arithmetization::all_stark::AllStark">AllStark</a>&lt;F, D&gt;,
    degree_bits_ranges: &amp;[<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">9</a>],
    stark_config: &amp;<a class="struct" href="../struct.StarkConfig.html" title="struct evm_arithmetization::StarkConfig">StarkConfig</a>,
) -&gt; Self</h4></section></summary><div class="docblock"><p>Preprocess all recursive circuits used by the system.</p>
<h5 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments</h5>
<ul>
<li><code>all_stark</code>: a structure defining the logic of all STARK modules and
their associated cross-table lookups.</li>
<li><code>degree_bits_ranges</code>: the logarithmic ranges to be supported for the
recursive tables.</li>
</ul>
<p>Transactions may yield arbitrary trace lengths for each STARK module
(within some bounds), unknown prior generating the witness to create
a proof. Thus, for each STARK module, we construct a map from
<code>2^{degree_bits} = length</code> to a chain of shrinking recursion circuits,
starting from that length, for each <code>degree_bits</code> in the range specified
for this STARK module. Specifying a wide enough range allows a
prover to cover all possible scenarios.</p>
<ul>
<li><code>stark_config</code>: the configuration to be used for the STARK prover. It
will usually be a fast one yielding large proofs.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.final_verifier_data" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#744-746">source</a><h4 class="code-header">pub fn <a href="#method.final_verifier_data" class="fn">final_verifier_data</a>(&amp;self) -&gt; VerifierCircuitData&lt;F, C, D&gt;</h4></section></summary><div class="docblock"><p>Outputs the <code>VerifierCircuitData</code> needed to verify any block proof
generated by an honest prover.
While the <a href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits"><code>AllRecursiveCircuits</code></a> prover state can also verify proofs,
verifiers only need a fraction of the state to verify proofs. This
allows much less powerful entities to behave as verifiers, by only
loading the necessary data to verify block proofs.</p>
<h5 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>prover_state = AllRecursiveCircuits { ... };
<span class="kw">let </span>verifier_state = prover_state.final_verifier_data();

<span class="comment">// Verify a provided block proof
</span><span class="macro">assert!</span>(verifier_state.verify(<span class="kw-2">&amp;</span>block_proof).is_ok());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prove_segment" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1647-1716">source</a><h4 class="code-header">pub fn <a href="#method.prove_segment" class="fn">prove_segment</a>(
    &amp;self,
    all_stark: &amp;<a class="struct" href="../all_stark/struct.AllStark.html" title="struct evm_arithmetization::all_stark::AllStark">AllStark</a>&lt;F, D&gt;,
    config: &amp;<a class="struct" href="../struct.StarkConfig.html" title="struct evm_arithmetization::StarkConfig">StarkConfig</a>,
    generation_inputs: <a class="struct" href="../generation/struct.TrimmedGenerationInputs.html" title="struct evm_arithmetization::generation::TrimmedGenerationInputs">TrimmedGenerationInputs</a>,
    segment_data: &amp;mut <a class="struct" href="../struct.GenerationSegmentData.html" title="struct evm_arithmetization::GenerationSegmentData">GenerationSegmentData</a>,
    timing: &amp;mut TimingTree,
    abort_signal: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html" title="struct core::sync::atomic::AtomicBool">AtomicBool</a>&gt;&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="struct" href="struct.ProverOutputData.html" title="struct evm_arithmetization::fixed_recursive_verifier::ProverOutputData">ProverOutputData</a>&lt;F, C, D&gt;&gt;</h4></section></summary><div class="docblock"><p>For a given transaction payload passed as <a href="../generation/struct.GenerationInputs.html" title="struct evm_arithmetization::generation::GenerationInputs"><code>GenerationInputs</code></a>, create a
proof for each STARK module, then recursively shrink and combine
them, eventually culminating in a transaction proof, also called
root proof.</p>
<h5 id="arguments-3"><a class="doc-anchor" href="#arguments-3">§</a>Arguments</h5>
<ul>
<li><code>all_stark</code>: a structure defining the logic of all STARK modules and
their associated cross-table lookups.</li>
<li><code>config</code>: the configuration to be used for the STARK prover. It will
usually be a fast one yielding large proofs.</li>
<li><code>generation_inputs</code>: a transaction and auxiliary data needed to
generate a proof, provided in Intermediary Representation.</li>
<li><code>timing</code>: a profiler defining a scope hierarchy and the time consumed
by each one.</li>
<li><code>abort_signal</code>: an optional <a href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html" title="struct core::sync::atomic::AtomicBool"><code>AtomicBool</code></a> wrapped behind an <a href="https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc"><code>Arc</code></a>,
to send a kill signal early. This is only necessary in a distributed
setting where a worker may be blocking the entire queue.</li>
</ul>
<h5 id="outputs"><a class="doc-anchor" href="#outputs">§</a>Outputs</h5>
<p>This method outputs a tuple of [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>] and
its <a href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues"><code>PublicValues</code></a>. Only the proof with public inputs is necessary
for a verifier to assert correctness of the computation,
but the public values are output for the prover convenience, as these
are necessary during proof aggregation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prove_all_segments" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1720-1757">source</a><h4 class="code-header">pub fn <a href="#method.prove_all_segments" class="fn">prove_all_segments</a>(
    &amp;self,
    all_stark: &amp;<a class="struct" href="../all_stark/struct.AllStark.html" title="struct evm_arithmetization::all_stark::AllStark">AllStark</a>&lt;F, D&gt;,
    config: &amp;<a class="struct" href="../struct.StarkConfig.html" title="struct evm_arithmetization::StarkConfig">StarkConfig</a>,
    generation_inputs: <a class="struct" href="../generation/struct.GenerationInputs.html" title="struct evm_arithmetization::generation::GenerationInputs">GenerationInputs</a>,
    max_cpu_len_log: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    timing: &amp;mut TimingTree,
    abort_signal: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html" title="struct core::sync::atomic::AtomicBool">AtomicBool</a>&gt;&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.ProverOutputData.html" title="struct evm_arithmetization::fixed_recursive_verifier::ProverOutputData">ProverOutputData</a>&lt;F, C, D&gt;&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a proof for each segment that is part of a full transaction
proof.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prove_segment_after_initial_stark" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1809-1850">source</a><h4 class="code-header">pub fn <a href="#method.prove_segment_after_initial_stark" class="fn">prove_segment_after_initial_stark</a>(
    &amp;self,
    all_proof: <a class="struct" href="../proof/struct.AllProof.html" title="struct evm_arithmetization::proof::AllProof">AllProof</a>&lt;F, C, D&gt;,
    table_circuits: &amp;[(<a class="struct" href="struct.RecursiveCircuitsForTableSize.html" title="struct evm_arithmetization::fixed_recursive_verifier::RecursiveCircuitsForTableSize">RecursiveCircuitsForTableSize</a>&lt;F, C, D&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>); <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">9</a>],
    abort_signal: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html" title="struct core::sync::atomic::AtomicBool">AtomicBool</a>&gt;&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;(ProofWithPublicInputs&lt;F, C, D&gt;, <a class="struct" href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues">PublicValues</a>)&gt;</h4></section></summary><div class="docblock"><p>From an initial set of STARK proofs passed with their associated
recursive table circuits, generate a recursive transaction proof.
It is aimed at being used when preprocessed table circuits have not been
loaded to memory.</p>
<p><strong>Note</strong>:
The type of the <code>table_circuits</code> passed as arguments is
<code>&amp;[(RecursiveCircuitsForTableSize&lt;F, C, D&gt;, u8); NUM_TABLES]</code>. In
particular, for each STARK proof contained within the <code>AllProof</code>
object provided to this method, we need to pass a tuple
of <a href="struct.RecursiveCircuitsForTableSize.html" title="struct evm_arithmetization::fixed_recursive_verifier::RecursiveCircuitsForTableSize"><code>RecursiveCircuitsForTableSize&lt;F, C, D&gt;</code></a> and a <a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" title="primitive u8"><code>u8</code></a>. The former
is the recursive chain corresponding to the initial degree size of
the associated STARK proof. The latter is the index of this degree
in the range that was originally passed when constructing the entire
prover state.</p>
<h5 id="usage-1"><a class="doc-anchor" href="#usage-1">§</a>Usage</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Load a prover state without its recursive table circuits.
</span><span class="kw">let </span>gate_serializer = DefaultGateSerializer;
<span class="kw">let </span>generator_serializer = DefaultGeneratorSerializer::&lt;C, D&gt;::new();
<span class="kw">let </span>initial_ranges = [<span class="number">16</span>..<span class="number">25</span>, <span class="number">10</span>..<span class="number">20</span>, <span class="number">12</span>..<span class="number">25</span>, <span class="number">14</span>..<span class="number">25</span>, <span class="number">9</span>..<span class="number">20</span>, <span class="number">12</span>..<span class="number">20</span>, <span class="number">17</span>..<span class="number">30</span>];
<span class="kw">let </span>prover_state = AllRecursiveCircuits::&lt;F, C, D&gt;::new(
    <span class="kw-2">&amp;</span>all_stark,
    <span class="kw-2">&amp;</span>initial_ranges,
    <span class="kw-2">&amp;</span>config,
);

<span class="comment">// Generate a proof from the provided inputs.
</span><span class="kw">let </span>stark_proof = prove::&lt;F, C, D&gt;(<span class="kw-2">&amp;</span>all_stark, <span class="kw-2">&amp;</span>config, inputs, <span class="kw-2">&amp;mut </span>timing, abort_signal).unwrap();

<span class="comment">// Read the degrees of the internal STARK proofs.
// Indices to be passed along the recursive tables
// can be easily recovered as `initial_ranges[i]` - `degrees[i]`.
</span><span class="kw">let </span>degrees = proof.degree_bits(<span class="kw-2">&amp;</span>config);

<span class="comment">// Retrieve the corresponding recursive table circuits for each table with the corresponding degree.
</span><span class="kw">let </span>table_circuits = { ... };

<span class="comment">// Finally shrink the STARK proof.
</span><span class="kw">let </span>(proof, public_values) = prove_segment_after_initial_stark(
    <span class="kw-2">&amp;</span>all_stark,
    <span class="kw-2">&amp;</span>config,
    <span class="kw-2">&amp;</span>stark_proof,
    <span class="kw-2">&amp;</span>table_circuits,
    <span class="kw-2">&amp;mut </span>timing,
    abort_signal,
).unwrap();</code></pre></div>
</div></details><section id="method.verify_root" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1852-1854">source</a><h4 class="code-header">pub fn <a href="#method.verify_root" class="fn">verify_root</a>(
    &amp;self,
    agg_proof: ProofWithPublicInputs&lt;F, C, D&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.prove_segment_aggregation" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1879-1963">source</a><h4 class="code-header">pub fn <a href="#method.prove_segment_aggregation" class="fn">prove_segment_aggregation</a>(
    &amp;self,
    lhs_is_agg: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    lhs_prover_output: &amp;<a class="struct" href="struct.ProverOutputData.html" title="struct evm_arithmetization::fixed_recursive_verifier::ProverOutputData">ProverOutputData</a>&lt;F, C, D&gt;,
    rhs_is_agg: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    rhs_prover_output: &amp;<a class="struct" href="struct.ProverOutputData.html" title="struct evm_arithmetization::fixed_recursive_verifier::ProverOutputData">ProverOutputData</a>&lt;F, C, D&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="struct" href="struct.ProverOutputData.html" title="struct evm_arithmetization::fixed_recursive_verifier::ProverOutputData">ProverOutputData</a>&lt;F, C, D&gt;&gt;</h4></section></summary><div class="docblock"><p>Create an aggregation proof, combining two contiguous proofs into a
single one. The combined proofs are segment proofs: they are proofs
of some parts of one execution.</p>
<p>While regular root proofs can only assert validity of a
single segment of a transaction, segment aggregation proofs
can cover an arbitrary range, up to an entire transaction.</p>
<h5 id="arguments-4"><a class="doc-anchor" href="#arguments-4">§</a>Arguments</h5>
<ul>
<li><code>lhs_is_agg</code>: a boolean indicating whether the left child proof is an
aggregation proof or a regular segment proof.</li>
<li><code>lhs_proof</code>: the left child prover output data.</li>
<li><code>rhs_is_agg</code>: a boolean indicating whether the right child proof is an
aggregation proof or a regular transaction proof.</li>
<li><code>rhs_proof</code>: the right child prover output data.</li>
</ul>
<h5 id="outputs-1"><a class="doc-anchor" href="#outputs-1">§</a>Outputs</h5>
<p>This method outputs a <a href="struct.ProverOutputData.html" title="struct evm_arithmetization::fixed_recursive_verifier::ProverOutputData"><code>ProverOutputData&lt;F, C, D&gt;</code></a>. Only the proof with
public inputs is necessary for a verifier to assert correctness of
the computation, but the public values and <code>is_dummy</code> are output for the
prover convenience, as these are necessary during proof aggregation.</p>
</div></details><section id="method.verify_segment_aggregation" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1965-1975">source</a><h4 class="code-header">pub fn <a href="#method.verify_segment_aggregation" class="fn">verify_segment_aggregation</a>(
    &amp;self,
    agg_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.prove_transaction_aggregation" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#1999-2052">source</a><h4 class="code-header">pub fn <a href="#method.prove_transaction_aggregation" class="fn">prove_transaction_aggregation</a>(
    &amp;self,
    lhs_is_agg: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    lhs_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
    lhs_public_values: <a class="struct" href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues">PublicValues</a>,
    rhs_is_agg: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    rhs_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
    rhs_public_values: <a class="struct" href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues">PublicValues</a>,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;(ProofWithPublicInputs&lt;F, C, D&gt;, <a class="struct" href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues">PublicValues</a>)&gt;</h4></section></summary><div class="docblock"><p>Creates a final transaction proof, once all segments of a given
transaction have been combined into a single aggregation proof.</p>
<p>Transaction proofs can either be generated as a standalone, or combined
with a previous transaction proof to assert validity of a range of
transactions.</p>
<h5 id="arguments-5"><a class="doc-anchor" href="#arguments-5">§</a>Arguments</h5>
<ul>
<li><code>opt_parent_txn_proof</code>: an optional parent transaction proof. Passing
one will generate a proof of validity for both the transaction range
covered by the previous proof and the current transaction.</li>
<li><code>agg_proof</code>: the final aggregation proof containing all segments
within the current transaction.</li>
<li><code>public_values</code>: the public values associated to the aggregation
proof.</li>
</ul>
<h5 id="outputs-2"><a class="doc-anchor" href="#outputs-2">§</a>Outputs</h5>
<p>This method outputs a tuple of [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>] and
its <a href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues"><code>PublicValues</code></a>. Only the proof with public inputs is necessary
for a verifier to assert correctness of the computation.</p>
</div></details><section id="method.verify_txn_aggregation" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#2054-2064">source</a><h4 class="code-header">pub fn <a href="#method.verify_txn_aggregation" class="fn">verify_txn_aggregation</a>(
    &amp;self,
    txn_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.prove_block" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#2114-2250">source</a><h4 class="code-header">pub fn <a href="#method.prove_block" class="fn">prove_block</a>(
    &amp;self,
    opt_parent_block_proof: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;ProofWithPublicInputs&lt;F, C, D&gt;&gt;,
    agg_root_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
    public_values: <a class="struct" href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues">PublicValues</a>,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;(ProofWithPublicInputs&lt;F, C, D&gt;, <a class="struct" href="../proof/struct.FinalPublicValues.html" title="struct evm_arithmetization::proof::FinalPublicValues">FinalPublicValues</a>)&gt;</h4></section></summary><div class="docblock"><p>Create a final block proof, once all transactions of a given block have
been combined into a single aggregation proof.</p>
<p>Block proofs can either be generated as standalone, or combined with a
previous block proof to assert validity of a range of blocks.</p>
<h5 id="arguments-6"><a class="doc-anchor" href="#arguments-6">§</a>Arguments</h5>
<ul>
<li><code>opt_parent_block_proof</code>: an optional parent block proof. Passing one
will generate a proof of validity for both the block range covered by
the previous proof and the current block.</li>
<li><code>agg_root_proof</code>: the final aggregation proof containing all
transactions within the current block.</li>
<li><code>public_values</code>: the public values associated to the aggregation
proof.</li>
</ul>
<h5 id="outputs-3"><a class="doc-anchor" href="#outputs-3">§</a>Outputs</h5>
<p>This method outputs a tuple of [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>] and
its <a href="../proof/struct.PublicValues.html" title="struct evm_arithmetization::proof::PublicValues"><code>PublicValues</code></a>. Only the proof with public inputs is necessary
for a verifier to assert correctness of the computation.</p>
</div></details><section id="method.verify_block" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#2252-2259">source</a><h4 class="code-header">pub fn <a href="#method.verify_block" class="fn">verify_block</a>(
    &amp;self,
    block_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.prove_two_to_one_block" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#2273-2305">source</a><h4 class="code-header">pub fn <a href="#method.prove_two_to_one_block" class="fn">prove_two_to_one_block</a>(
    &amp;self,
    lhs: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
    lhs_is_agg: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    rhs: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
    rhs_is_agg: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;ProofWithPublicInputs&lt;F, C, D&gt;&gt;</h4></section></summary><div class="docblock"><p>Aggregates two proofs in manner similar to [<code>prove_aggregation</code>].</p>
<h5 id="arguments-7"><a class="doc-anchor" href="#arguments-7">§</a>Arguments</h5>
<ul>
<li><code>lhs</code>: a proof of either a block or previous aggregation.</li>
<li><code>lhs_is_agg</code>: specify which case <code>lhs</code> was.</li>
<li><code>rhs</code>: a proof of either a block or previous aggregation.</li>
<li><code>rhs_is_agg</code>: specify which case <code>rhs</code> was.</li>
</ul>
<h5 id="outputs-4"><a class="doc-anchor" href="#outputs-4">§</a>Outputs</h5>
<p>Returns a [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>].</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.verify_two_to_one_block" class="method"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#2316-2323">source</a><h4 class="code-header">pub fn <a href="#method.verify_two_to_one_block" class="fn">verify_two_to_one_block</a>(
    &amp;self,
    proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,
) -&gt; <a class="type" href="https://docs.rs/anyhow/1.0.85/anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Verifies an existing block aggregation proof.</p>
<h5 id="arguments-8"><a class="doc-anchor" href="#arguments-8">§</a>Arguments</h5>
<ul>
<li><code>proof</code>: The proof generated with <code>prove_two_to_one_block</code>.</li>
</ul>
<h5 id="outputs-5"><a class="doc-anchor" href="#outputs-5">§</a>Outputs</h5>
<p>Returns whether the proof was valid or not.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#78">source</a><a href="#impl-Debug-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    F: RichField + Extendable&lt;D&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,
    C: GenericConfig&lt;D, F = F&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,
    C::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#78">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#78">source</a><a href="#impl-PartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    F: RichField + Extendable&lt;D&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,
    C: GenericConfig&lt;D, F = F&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,
    C::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#78">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#261">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#78">source</a><a href="#impl-Eq-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    F: RichField + Extendable&lt;D&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>,
    C: GenericConfig&lt;D, F = F&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>,
    C::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section><section id="impl-StructuralPartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/evm_arithmetization/fixed_recursive_verifier.rs.html#78">source</a><a href="#impl-StructuralPartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    F: RichField + Extendable&lt;D&gt;,
    C: GenericConfig&lt;D, F = F&gt;,
    C::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a href="#impl-Freeze-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a href="#impl-RefUnwindSafe-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;</h3></section><section id="impl-Send-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a href="#impl-Send-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section><section id="impl-Sync-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a href="#impl-Sync-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section><section id="impl-Unpin-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a href="#impl-Unpin-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;<div class="where">where
    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="impl"><a href="#impl-UnwindSafe-for-AllRecursiveCircuits%3CF,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F, C, const D: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>&lt;F, C, D&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Equivalent&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a href="#method.equivalent" class="anchor">§</a><h4 class="code-header">fn <a class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Checks if this value is equivalent to the given key. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pointable for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.17.0/src/typenum/type_operators.rs.html#34">source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.17.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.17.0/src/typenum/type_operators.rs.html#35">source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.17.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#809">source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details></div></section></div></main></body></html>