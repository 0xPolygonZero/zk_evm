<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An implementation of a Type 1 zk-EVM by Polygon Zero."><title>evm_arithmetization - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="evm_arithmetization" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (1f12b9b0f 2024-08-27)" data-channel="nightly" data-search-js="search-acd2e111c9cb27e3.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
    integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
    integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            fleqn: false,
            macros: {
                "\\F": "\\mathbb{F}",
                "\\G": "\\mathbb{G}",
                "\\O": "\\mathcal{O}",
                "\\(": "\\left(",
                "\\)": "\\right)",
                "\\norm": "\\left\\vert #1 \\right\\vert",
                "\\set": "\\mathcal{ #1 }",
            },
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\(", right: "\\)", display: false },
                { left: "$", right: "$", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    });
</script>
</head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../evm_arithmetization/index.html">evm_<wbr>arithmetization</a><span class="version">0.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">evm_arithmetization</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/evm_arithmetization/lib.rs.html#1-233">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An implementation of a Type 1 zk-EVM by Polygon Zero.</p>
<p>Following the <a href="https://vitalik.eth.limo/general/2022/08/04/zkevm.html">zk-EVM classification of V. Buterin</a>,
the evm_arithmetization crate aims at providing an efficient solution for
the problem of generating cryptographic proofs of Ethereum-like transactions
with <em>full Ethereum capability</em>.</p>
<p>To this end, the plonky2 zk-EVM is tailored for an AIR-based STARK system
satisfying degree 3 constraints, with support for recursive aggregation
leveraging plonky2 circuits with FRI-based plonkish arithmetization.
These circuits require a one-time, offline preprocessing phase.
See the <a href="fixed_recursive_verifier/index.html" title="mod evm_arithmetization::fixed_recursive_verifier"><code>fixed_recursive_verifier</code></a> module for more details on how this
works. These preprocessed circuits are gathered within the
<a href="fixed_recursive_verifier/struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits"><code>AllRecursiveCircuits</code></a> prover state, and can be generated as such:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Specify the base field to use.
</span><span class="kw">type </span>F = GoldilocksField;
<span class="comment">// Specify the extension degree to use.
</span><span class="kw">const </span>D: usize = <span class="number">2</span>;
<span class="comment">// Specify the recursive configuration to use, here leveraging Poseidon hash
// over the Goldilocks field both natively and in-circuit.
</span><span class="kw">type </span>C = PoseidonGoldilocksConfig;

<span class="kw">let </span>all_stark = AllStark::&lt;F, D&gt;::default();
<span class="kw">let </span>config = StarkConfig::standard_fast_config();

<span class="comment">// Generate all the recursive circuits needed to generate succinct proofs for blocks.
// The ranges correspond to the supported table sizes for each individual STARK component.
</span><span class="kw">let </span>prover_state = AllRecursiveCircuits::&lt;F, C, D&gt;::new(
    <span class="kw-2">&amp;</span>all_stark,
    <span class="kw-2">&amp;</span>[<span class="number">16</span>..<span class="number">25</span>, <span class="number">10</span>..<span class="number">20</span>, <span class="number">12</span>..<span class="number">25</span>, <span class="number">14</span>..<span class="number">25</span>, <span class="number">9</span>..<span class="number">20</span>, <span class="number">12</span>..<span class="number">20</span>, <span class="number">17</span>..<span class="number">30</span>],
    <span class="kw-2">&amp;</span>config,
);</code></pre></div>
<h2 id="inputs-type"><a class="doc-anchor" href="#inputs-type">§</a>Inputs type</h2>
<p>Transactions need to be processed into an Intermediary Representation (IR)
format for the prover to be able to generate proofs of valid state
transition. This involves passing the encoded transaction, the header of the
block in which it was included, some information on the state prior
execution of this transaction, etc.
This intermediary representation is called <a href="generation/struct.GenerationInputs.html" title="struct evm_arithmetization::generation::GenerationInputs"><code>GenerationInputs</code></a>.</p>
<h2 id="generating-succinct-proofs"><a class="doc-anchor" href="#generating-succinct-proofs">§</a>Generating succinct proofs</h2><h3 id="transaction-proofs"><a class="doc-anchor" href="#transaction-proofs">§</a>Transaction proofs</h3>
<p>To generate a proof for a transaction, given its <a href="generation/struct.GenerationInputs.html" title="struct evm_arithmetization::generation::GenerationInputs"><code>GenerationInputs</code></a> and an
<a href="fixed_recursive_verifier/struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits"><code>AllRecursiveCircuits</code></a> prover state, one can simply call the
<a href="AllRecursiveCircuits::prove_root">prove_root</a> method.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>timing = TimingTree::new(<span class="string">"prove"</span>, log::Level::Debug);
<span class="kw">let </span>kill_signal = <span class="prelude-val">None</span>; <span class="comment">// Useful only with distributed proving to kill hanging jobs.
</span><span class="kw">let </span>(proof, public_values) =
    prover_state.prove_root(all_stark, config, inputs, <span class="kw-2">&amp;mut </span>timing, kill_signal);</code></pre></div>
<p>This outputs a transaction proof and its associated public values. These are
necessary during the aggregation levels (see below). If one were to miss the
public values, they are also retrievable directly from the proof’s encoded
public inputs, as such:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>public_values = PublicValues::from_public_inputs(<span class="kw-2">&amp;</span>proof.public_inputs);</code></pre></div>
<h3 id="aggregation-proofs"><a class="doc-anchor" href="#aggregation-proofs">§</a>Aggregation proofs</h3>
<p>Because the plonky2 zkEVM generates proofs on a transaction basis, we then
need to aggregate them for succinct verification. This is done in a binary
tree fashion, where each inner node proof verifies two children proofs,
through the <a href="AllRecursiveCircuits::prove_aggregation">prove_aggregation</a>
method. Note that the tree does <em>not</em> need to be complete, as this
aggregation process can take as inputs both regular transaction proofs and
aggregation proofs. We only need to specify for each child if it is an
aggregation proof or a regular one.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(proof_1, pv_1) =
    prover_state.prove_root(all_stark, config, inputs_1, <span class="kw-2">&amp;mut </span>timing, <span class="prelude-val">None</span>);
<span class="kw">let </span>(proof_2, pv_2) =
    prover_state.prove_root(all_stark, config, inputs_2, <span class="kw-2">&amp;mut </span>timing, <span class="prelude-val">None</span>);
<span class="kw">let </span>(proof_3, pv_3) =
    prover_state.prove_root(all_stark, config, inputs_3, <span class="kw-2">&amp;mut </span>timing, <span class="prelude-val">None</span>);

<span class="comment">// Now aggregate proofs for txn 1 and 2.
</span><span class="kw">let </span>(agg_proof_1_2, pv_1_2) =
    prover_state.prove_aggregation(<span class="bool-val">false</span>, proof_1, pv_1, <span class="bool-val">false</span>, proof_2, pv_2);

<span class="comment">// Now aggregate the newly generated aggregation proof with the last regular txn proof.
</span><span class="kw">let </span>(agg_proof_1_3, pv_1_3) =
    prover_state.prove_aggregation(<span class="bool-val">true</span>, agg_proof_1_2, pv_1_2, <span class="bool-val">false</span>, proof_3, pv_3);</code></pre></div>
<p><strong>Note</strong>: The proofs provided to the
<a href="AllRecursiveCircuits::prove_aggregation">prove_aggregation</a> method <em>MUST</em>
have contiguous states. Trying to combine <code>proof_1</code> and <code>proof_3</code> from the
example above would fail.</p>
<h3 id="block-proofs"><a class="doc-anchor" href="#block-proofs">§</a>Block proofs</h3>
<p>Once all transactions of a block have been proven and we are left with a
single aggregation proof and its public values, we can then wrap it into a
final block proof, attesting validity of the entire block.
This <a href="fixed_recursive_verifier/struct.AllRecursiveCircuits.html#method.prove_block" title="method evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits::prove_block">prove_block</a> method accepts an
optional previous block proof as argument, which will then try combining the
previously proven block with the current one, generating a validity proof
for both. Applying this process from genesis would yield a single proof
attesting correctness of the entire chain.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>previous_block_proof = { ... };
<span class="kw">let </span>(block_proof, block_public_values) =
    prover_state.prove_block(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>previous_block_proof), <span class="kw-2">&amp;</span>agg_proof, agg_pv)<span class="question-mark">?</span>;</code></pre></div>
<h4 id="checkpoint-heights"><a class="doc-anchor" href="#checkpoint-heights">§</a>Checkpoint heights</h4>
<p>The process of always providing a previous block proof when generating a
proof for the current block may yield some undesirable issues. For this
reason, the plonky2 zk-EVM supports checkpoint heights. At given block
heights, the prover does not have to pass a previous block proof. This would
in practice correspond to block heights at which a proof has been generated
and sent to L1 for settlement.</p>
<p>The only requirement when generating a block proof without passing a
previous one as argument is to have the <code>checkpoint_state_trie_root</code>
metadata in the <code>PublicValues</code> of the final aggregation proof be matching
the state trie before applying all the included transactions. If this
condition is not met, the prover will fail to generate a valid proof.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(block_proof, block_public_values) =
    prover_state.prove_block(<span class="prelude-val">None</span>, <span class="kw-2">&amp;</span>agg_proof, agg_pv)<span class="question-mark">?</span>;</code></pre></div>
<h2 id="prover-state-serialization"><a class="doc-anchor" href="#prover-state-serialization">§</a>Prover state serialization</h2>
<p>Because the recursive circuits only need to be generated once, they can be
saved to disk once the preprocessing phase completed successfully, and
deserialized on-demand. The plonky2 zk-EVM provides serialization methods to
convert the entire prover state to a vector of bytes, and vice-versa.
This requires the use of custom serializers for gates and generators for
proper recursive circuit encoding. This crate provides default serializers
supporting all custom gates and associated generators defined within the
[<code>plonky2</code>] crate.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>prover_state = AllRecursiveCircuits::&lt;F, C, D&gt;::new(...);

<span class="comment">// Default serializers
</span><span class="kw">let </span>gate_serializer = DefaultGateSerializer;
<span class="kw">let </span>generator_serializer = DefaultGeneratorSerializer::&lt;C, D&gt; {
    _phantom: PhantomData::&lt;C&gt;,
};

<span class="comment">// Serialize the prover state to a sequence of bytes
</span><span class="kw">let </span>bytes = prover_state.to_bytes(<span class="bool-val">false</span>, <span class="kw-2">&amp;</span>gate_serializer, <span class="kw-2">&amp;</span>generator_serializer).unwrap();

<span class="comment">// Deserialize the bytes into a prover state
</span><span class="kw">let </span>recovered_prover_state = AllRecursiveCircuits::&lt;F, C, D&gt;::from_bytes(
    <span class="kw-2">&amp;</span>all_circuits_bytes,
    <span class="bool-val">false</span>,
    <span class="kw-2">&amp;</span>gate_serializer,
    <span class="kw-2">&amp;</span>generator_serializer,
).unwrap();

<span class="macro">assert_eq!</span>(prover_state, recovered_prover_state);</code></pre></div>
<p>Note that an entire prover state built with wide ranges may be particularly
large (up to ~25 GB), hence serialization methods, while faster than doing
another preprocessing, may take some non-negligible time.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.AllStark"><code>pub use all_stark::<a class="struct" href="all_stark/struct.AllStark.html" title="struct evm_arithmetization::all_stark::AllStark">AllStark</a>;</code></div></li><li><div class="item-name" id="reexport.AllRecursiveCircuits"><code>pub use fixed_recursive_verifier::<a class="struct" href="fixed_recursive_verifier/struct.AllRecursiveCircuits.html" title="struct evm_arithmetization::fixed_recursive_verifier::AllRecursiveCircuits">AllRecursiveCircuits</a>;</code></div></li><li><div class="item-name" id="reexport.GenerationInputs"><code>pub use generation::<a class="struct" href="generation/struct.GenerationInputs.html" title="struct evm_arithmetization::generation::GenerationInputs">GenerationInputs</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="all_stark/index.html" title="mod evm_arithmetization::all_stark">all_<wbr>stark</a></div></li><li><div class="item-name"><a class="mod" href="arithmetic/index.html" title="mod evm_arithmetization::arithmetic">arithmetic</a></div></li><li><div class="item-name"><a class="mod" href="byte_packing/index.html" title="mod evm_arithmetization::byte_packing">byte_<wbr>packing</a></div><div class="desc docblock-short">Byte packing / unpacking unit for the EVM.</div></li><li><div class="item-name"><a class="mod" href="cpu/index.html" title="mod evm_arithmetization::cpu">cpu</a></div></li><li><div class="item-name"><a class="mod" href="curve_pairings/index.html" title="mod evm_arithmetization::curve_pairings">curve_<wbr>pairings</a></div></li><li><div class="item-name"><a class="mod" href="extension_tower/index.html" title="mod evm_arithmetization::extension_tower">extension_<wbr>tower</a></div></li><li><div class="item-name"><a class="mod" href="fixed_recursive_verifier/index.html" title="mod evm_arithmetization::fixed_recursive_verifier">fixed_<wbr>recursive_<wbr>verifier</a></div></li><li><div class="item-name"><a class="mod" href="generation/index.html" title="mod evm_arithmetization::generation">generation</a></div></li><li><div class="item-name"><a class="mod" href="keccak/index.html" title="mod evm_arithmetization::keccak">keccak</a></div></li><li><div class="item-name"><a class="mod" href="keccak_sponge/index.html" title="mod evm_arithmetization::keccak_sponge">keccak_<wbr>sponge</a></div><div class="desc docblock-short">The Keccak sponge STARK is used to hash a variable amount of data which is
read from memory. It connects to the memory STARK to read input data, and to
the Keccak-f STARK to evaluate the permutation at each absorption step.</div></li><li><div class="item-name"><a class="mod" href="logic/index.html" title="mod evm_arithmetization::logic">logic</a></div></li><li><div class="item-name"><a class="mod" href="memory/index.html" title="mod evm_arithmetization::memory">memory</a></div><div class="desc docblock-short">The Memory STARK is used to handle all memory read and write operations
happening when executing the EVM. Each non-dummy row of the table correspond
to a single operation, and rows are ordered by the timestamp associated to
each memory operation.</div></li><li><div class="item-name"><a class="mod" href="memory_continuation/index.html" title="mod evm_arithmetization::memory_continuation">memory_<wbr>continuation</a></div><div class="desc docblock-short">The MemAfter STARK is used to store the memory state at the end of the
execution. It connects to the memory STARK to read the final values of all
touched addresses.</div></li><li><div class="item-name"><a class="mod" href="proof/index.html" title="mod evm_arithmetization::proof">proof</a></div></li><li><div class="item-name"><a class="mod" href="prover/index.html" title="mod evm_arithmetization::prover">prover</a></div></li><li><div class="item-name"><a class="mod" href="recursive_verifier/index.html" title="mod evm_arithmetization::recursive_verifier">recursive_<wbr>verifier</a></div></li><li><div class="item-name"><a class="mod" href="testing_utils/index.html" title="mod evm_arithmetization::testing_utils">testing_<wbr>utils</a></div><div class="desc docblock-short">A set of utility functions and constants to be used by <code>evm_arithmetization</code>
unit and integration tests.</div></li><li><div class="item-name"><a class="mod" href="util/index.html" title="mod evm_arithmetization::util">util</a></div></li><li><div class="item-name"><a class="mod" href="verifier/index.html" title="mod evm_arithmetization::verifier">verifier</a></div></li><li><div class="item-name"><a class="mod" href="witness/index.html" title="mod evm_arithmetization::witness">witness</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.GenerationSegmentData.html" title="struct evm_arithmetization::GenerationSegmentData">Generation<wbr>Segment<wbr>Data</a></div><div class="desc docblock-short">Structure holding the data needed to initialize a segment.</div></li><li><div class="item-name"><a class="struct" href="struct.SegmentDataIterator.html" title="struct evm_arithmetization::SegmentDataIterator">Segment<wbr>Data<wbr>Iterator</a></div></li><li><div class="item-name"><a class="struct" href="struct.StarkConfig.html" title="struct evm_arithmetization::StarkConfig">Stark<wbr>Config</a></div><div class="desc docblock-short">A configuration containing the different parameters used by the STARK prover.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.AllData.html" title="type evm_arithmetization::AllData">AllData</a></div><div class="desc docblock-short">Returned type from a <code>SegmentDataIterator</code>, needed to prove all segments in
a transaction batch.</div></li><li><div class="item-name"><a class="type" href="type.BlockHeight.html" title="type evm_arithmetization::BlockHeight">Block<wbr>Height</a></div><div class="desc docblock-short">A type alias for <code>u64</code> of a block height.</div></li><li><div class="item-name"><a class="type" href="type.Node.html" title="type evm_arithmetization::Node">Node</a></div></li></ul></section></div></main></body></html>