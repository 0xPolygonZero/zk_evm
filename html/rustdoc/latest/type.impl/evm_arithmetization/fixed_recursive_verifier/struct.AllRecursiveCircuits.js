(function() {
    var type_impls = Object.fromEntries([["proof_gen",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"impl\"><a href=\"#impl-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F, C, const D: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>&gt; AllRecursiveCircuits&lt;F, C, D&gt;<div class=\"where\">where\n    F: RichField + Extendable&lt;D&gt;,\n    C: GenericConfig&lt;D, F = F&gt; + 'static,\n    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_bytes\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">to_bytes</a>(\n    &amp;self,\n    skip_tables: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n    gate_serializer: &amp;dyn GateSerializer&lt;F, D&gt;,\n    generator_serializer: &amp;dyn WitnessGeneratorSerializer&lt;F, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>&gt;, IoError&gt;</h4></section></summary><div class=\"docblock\"><p>Serializes all these preprocessed circuits into a sequence of bytes.</p>\n<h5 id=\"arguments\"><a class=\"doc-anchor\" href=\"#arguments\">§</a>Arguments</h5>\n<ul>\n<li><code>skip_tables</code>: a boolean indicating whether to serialize only the\nupper circuits or the entire prover state, including recursive\ncircuits to shrink STARK proofs.</li>\n<li><code>gate_serializer</code>: a custom gate serializer needed to serialize\nrecursive circuits common data.</li>\n<li><code>generator_serializer</code>: a custom generator serializer needed to\nserialize recursive circuits proving data.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_bytes\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">from_bytes</a>(\n    bytes: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>],\n    skip_tables: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n    gate_serializer: &amp;dyn GateSerializer&lt;F, D&gt;,\n    generator_serializer: &amp;dyn WitnessGeneratorSerializer&lt;F, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;AllRecursiveCircuits&lt;F, C, D&gt;, IoError&gt;</h4></section></summary><div class=\"docblock\"><p>Deserializes a sequence of bytes into an entire prover state containing\nall recursive circuits.</p>\n<h5 id=\"arguments-1\"><a class=\"doc-anchor\" href=\"#arguments-1\">§</a>Arguments</h5>\n<ul>\n<li><code>bytes</code>: a slice of bytes to deserialize this prover state from.</li>\n<li><code>skip_tables</code>: a boolean indicating whether to deserialize only the\nupper circuits or the entire prover state, including recursive\ncircuits to shrink STARK proofs.</li>\n<li><code>gate_serializer</code>: a custom gate serializer needed to serialize\nrecursive circuits common data.</li>\n<li><code>generator_serializer</code>: a custom generator serializer needed to\nserialize recursive circuits proving data.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new</a>(\n    all_stark: &amp;AllStark&lt;F, D&gt;,\n    degree_bits_ranges: &amp;[<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html\" title=\"struct core::ops::range::Range\">Range</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.array.html\">9</a>],\n    stark_config: &amp;StarkConfig,\n) -&gt; AllRecursiveCircuits&lt;F, C, D&gt;</h4></section></summary><div class=\"docblock\"><p>Preprocess all recursive circuits used by the system.</p>\n<h5 id=\"arguments-2\"><a class=\"doc-anchor\" href=\"#arguments-2\">§</a>Arguments</h5>\n<ul>\n<li><code>all_stark</code>: a structure defining the logic of all STARK modules and\ntheir associated cross-table lookups.</li>\n<li><code>degree_bits_ranges</code>: the logarithmic ranges to be supported for the\nrecursive tables.</li>\n</ul>\n<p>Transactions may yield arbitrary trace lengths for each STARK module\n(within some bounds), unknown prior generating the witness to create\na proof. Thus, for each STARK module, we construct a map from\n<code>2^{degree_bits} = length</code> to a chain of shrinking recursion circuits,\nstarting from that length, for each <code>degree_bits</code> in the range specified\nfor this STARK module. Specifying a wide enough range allows a\nprover to cover all possible scenarios.</p>\n<ul>\n<li><code>stark_config</code>: the configuration to be used for the STARK prover. It\nwill usually be a fast one yielding large proofs.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.final_verifier_data\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">final_verifier_data</a>(&amp;self) -&gt; VerifierCircuitData&lt;F, C, D&gt;</h4></section></summary><div class=\"docblock\"><p>Outputs the <code>VerifierCircuitData</code> needed to verify any block proof\ngenerated by an honest prover.\nWhile the [<code>AllRecursiveCircuits</code>] prover state can also verify proofs,\nverifiers only need a fraction of the state to verify proofs. This\nallows much less powerful entities to behave as verifiers, by only\nloading the necessary data to verify block proofs.</p>\n<h5 id=\"usage\"><a class=\"doc-anchor\" href=\"#usage\">§</a>Usage</h5>\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>prover_state = AllRecursiveCircuits { ... };\n<span class=\"kw\">let </span>verifier_state = prover_state.final_verifier_data();\n\n<span class=\"comment\">// Verify a provided block proof\n</span><span class=\"macro\">assert!</span>(verifier_state.verify(<span class=\"kw-2\">&amp;</span>block_proof).is_ok());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.prove_segment\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">prove_segment</a>(\n    &amp;self,\n    all_stark: &amp;AllStark&lt;F, D&gt;,\n    config: &amp;StarkConfig,\n    generation_inputs: TrimmedGenerationInputs,\n    segment_data: &amp;mut GenerationSegmentData,\n    timing: &amp;mut TimingTree,\n    abort_signal: <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html\" title=\"struct core::sync::atomic::AtomicBool\">AtomicBool</a>&gt;&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;ProverOutputData&lt;F, C, D&gt;, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>For a given transaction payload passed as [<code>GenerationInputs</code>], create a\nproof for each STARK module, then recursively shrink and combine\nthem, eventually culminating in a transaction proof, also called\nroot proof.</p>\n<h5 id=\"arguments-3\"><a class=\"doc-anchor\" href=\"#arguments-3\">§</a>Arguments</h5>\n<ul>\n<li><code>all_stark</code>: a structure defining the logic of all STARK modules and\ntheir associated cross-table lookups.</li>\n<li><code>config</code>: the configuration to be used for the STARK prover. It will\nusually be a fast one yielding large proofs.</li>\n<li><code>generation_inputs</code>: a transaction and auxiliary data needed to\ngenerate a proof, provided in Intermediary Representation.</li>\n<li><code>timing</code>: a profiler defining a scope hierarchy and the time consumed\nby each one.</li>\n<li><code>abort_signal</code>: an optional <a href=\"https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html\" title=\"struct core::sync::atomic::AtomicBool\"><code>AtomicBool</code></a> wrapped behind an <a href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\"><code>Arc</code></a>,\nto send a kill signal early. This is only necessary in a distributed\nsetting where a worker may be blocking the entire queue.</li>\n</ul>\n<h5 id=\"outputs\"><a class=\"doc-anchor\" href=\"#outputs\">§</a>Outputs</h5>\n<p>This method outputs a tuple of [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>] and\nits [<code>PublicValues</code>]. Only the proof with public inputs is necessary\nfor a verifier to assert correctness of the computation,\nbut the public values are output for the prover convenience, as these\nare necessary during proof aggregation.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.prove_all_segments\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">prove_all_segments</a>(\n    &amp;self,\n    all_stark: &amp;AllStark&lt;F, D&gt;,\n    config: &amp;StarkConfig,\n    generation_inputs: GenerationInputs,\n    max_cpu_len_log: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>,\n    timing: &amp;mut TimingTree,\n    abort_signal: <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html\" title=\"struct core::sync::atomic::AtomicBool\">AtomicBool</a>&gt;&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;ProverOutputData&lt;F, C, D&gt;&gt;, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a proof for each segment that is part of a full transaction\nproof.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.prove_segment_after_initial_stark\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">prove_segment_after_initial_stark</a>(\n    &amp;self,\n    all_proof: AllProof&lt;F, C, D&gt;,\n    table_circuits: &amp;[(RecursiveCircuitsForTableSize&lt;F, C, D&gt;, <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>); <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.array.html\">9</a>],\n    abort_signal: <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/sync/atomic/struct.AtomicBool.html\" title=\"struct core::sync::atomic::AtomicBool\">AtomicBool</a>&gt;&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;(ProofWithPublicInputs&lt;F, C, D&gt;, PublicValues), <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>From an initial set of STARK proofs passed with their associated\nrecursive table circuits, generate a recursive transaction proof.\nIt is aimed at being used when preprocessed table circuits have not been\nloaded to memory.</p>\n<p><strong>Note</strong>:\nThe type of the <code>table_circuits</code> passed as arguments is\n<code>&amp;[(RecursiveCircuitsForTableSize&lt;F, C, D&gt;, u8); NUM_TABLES]</code>. In\nparticular, for each STARK proof contained within the <code>AllProof</code>\nobject provided to this method, we need to pass a tuple\nof [<code>RecursiveCircuitsForTableSize&lt;F, C, D&gt;</code>] and a <a href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\" title=\"primitive u8\"><code>u8</code></a>. The former\nis the recursive chain corresponding to the initial degree size of\nthe associated STARK proof. The latter is the index of this degree\nin the range that was originally passed when constructing the entire\nprover state.</p>\n<h5 id=\"usage-1\"><a class=\"doc-anchor\" href=\"#usage-1\">§</a>Usage</h5>\n<div class=\"example-wrap ignore\"><a href=\"#\" class=\"tooltip\" title=\"This example is not tested\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Load a prover state without its recursive table circuits.\n</span><span class=\"kw\">let </span>gate_serializer = DefaultGateSerializer;\n<span class=\"kw\">let </span>generator_serializer = DefaultGeneratorSerializer::&lt;C, D&gt;::new();\n<span class=\"kw\">let </span>initial_ranges = [<span class=\"number\">16</span>..<span class=\"number\">25</span>, <span class=\"number\">10</span>..<span class=\"number\">20</span>, <span class=\"number\">12</span>..<span class=\"number\">25</span>, <span class=\"number\">14</span>..<span class=\"number\">25</span>, <span class=\"number\">9</span>..<span class=\"number\">20</span>, <span class=\"number\">12</span>..<span class=\"number\">20</span>, <span class=\"number\">17</span>..<span class=\"number\">30</span>];\n<span class=\"kw\">let </span>prover_state = AllRecursiveCircuits::&lt;F, C, D&gt;::new(\n    <span class=\"kw-2\">&amp;</span>all_stark,\n    <span class=\"kw-2\">&amp;</span>initial_ranges,\n    <span class=\"kw-2\">&amp;</span>config,\n);\n\n<span class=\"comment\">// Generate a proof from the provided inputs.\n</span><span class=\"kw\">let </span>stark_proof = prove::&lt;F, C, D&gt;(<span class=\"kw-2\">&amp;</span>all_stark, <span class=\"kw-2\">&amp;</span>config, inputs, <span class=\"kw-2\">&amp;mut </span>timing, abort_signal).unwrap();\n\n<span class=\"comment\">// Read the degrees of the internal STARK proofs.\n// Indices to be passed along the recursive tables\n// can be easily recovered as `initial_ranges[i]` - `degrees[i]`.\n</span><span class=\"kw\">let </span>degrees = proof.degree_bits(<span class=\"kw-2\">&amp;</span>config);\n\n<span class=\"comment\">// Retrieve the corresponding recursive table circuits for each table with the corresponding degree.\n</span><span class=\"kw\">let </span>table_circuits = { ... };\n\n<span class=\"comment\">// Finally shrink the STARK proof.\n</span><span class=\"kw\">let </span>(proof, public_values) = prove_segment_after_initial_stark(\n    <span class=\"kw-2\">&amp;</span>all_stark,\n    <span class=\"kw-2\">&amp;</span>config,\n    <span class=\"kw-2\">&amp;</span>stark_proof,\n    <span class=\"kw-2\">&amp;</span>table_circuits,\n    <span class=\"kw-2\">&amp;mut </span>timing,\n    abort_signal,\n).unwrap();</code></pre></div>\n</div></details><section id=\"method.verify_root\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">verify_root</a>(\n    &amp;self,\n    agg_proof: ProofWithPublicInputs&lt;F, C, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section><details class=\"toggle method-toggle\" open><summary><section id=\"method.prove_segment_aggregation\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">prove_segment_aggregation</a>(\n    &amp;self,\n    lhs_is_agg: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n    lhs_prover_output: &amp;ProverOutputData&lt;F, C, D&gt;,\n    rhs_is_agg: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n    rhs_prover_output: &amp;ProverOutputData&lt;F, C, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;ProverOutputData&lt;F, C, D&gt;, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Create an aggregation proof, combining two contiguous proofs into a\nsingle one. The combined proofs are segment proofs: they are proofs\nof some parts of one execution.</p>\n<p>While regular root proofs can only assert validity of a\nsingle segment of a transaction, segment aggregation proofs\ncan cover an arbitrary range, up to an entire transaction.</p>\n<h5 id=\"arguments-4\"><a class=\"doc-anchor\" href=\"#arguments-4\">§</a>Arguments</h5>\n<ul>\n<li><code>lhs_is_agg</code>: a boolean indicating whether the left child proof is an\naggregation proof or a regular segment proof.</li>\n<li><code>lhs_proof</code>: the left child prover output data.</li>\n<li><code>rhs_is_agg</code>: a boolean indicating whether the right child proof is an\naggregation proof or a regular transaction proof.</li>\n<li><code>rhs_proof</code>: the right child prover output data.</li>\n</ul>\n<h5 id=\"outputs-1\"><a class=\"doc-anchor\" href=\"#outputs-1\">§</a>Outputs</h5>\n<p>This method outputs a [<code>ProverOutputData&lt;F, C, D&gt;</code>]. Only the proof with\npublic inputs is necessary for a verifier to assert correctness of\nthe computation, but the public values and <code>is_dummy</code> are output for the\nprover convenience, as these are necessary during proof aggregation.</p>\n</div></details><section id=\"method.verify_segment_aggregation\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">verify_segment_aggregation</a>(\n    &amp;self,\n    agg_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section><details class=\"toggle method-toggle\" open><summary><section id=\"method.prove_transaction_aggregation\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">prove_transaction_aggregation</a>(\n    &amp;self,\n    lhs_is_agg: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n    lhs_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n    lhs_public_values: PublicValues,\n    rhs_is_agg: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n    rhs_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n    rhs_public_values: PublicValues,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;(ProofWithPublicInputs&lt;F, C, D&gt;, PublicValues), <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a final transaction proof, once all segments of a given\ntransaction have been combined into a single aggregation proof.</p>\n<p>Transaction proofs can either be generated as a standalone, or combined\nwith a previous transaction proof to assert validity of a range of\ntransactions.</p>\n<h5 id=\"arguments-5\"><a class=\"doc-anchor\" href=\"#arguments-5\">§</a>Arguments</h5>\n<ul>\n<li><code>opt_parent_txn_proof</code>: an optional parent transaction proof. Passing\none will generate a proof of validity for both the transaction range\ncovered by the previous proof and the current transaction.</li>\n<li><code>agg_proof</code>: the final aggregation proof containing all segments\nwithin the current transaction.</li>\n<li><code>public_values</code>: the public values associated to the aggregation\nproof.</li>\n</ul>\n<h5 id=\"outputs-2\"><a class=\"doc-anchor\" href=\"#outputs-2\">§</a>Outputs</h5>\n<p>This method outputs a tuple of [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>] and\nits [<code>PublicValues</code>]. Only the proof with public inputs is necessary\nfor a verifier to assert correctness of the computation.</p>\n</div></details><section id=\"method.verify_txn_aggregation\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">verify_txn_aggregation</a>(\n    &amp;self,\n    txn_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section><details class=\"toggle method-toggle\" open><summary><section id=\"method.prove_block\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">prove_block</a>(\n    &amp;self,\n    opt_parent_block_proof: <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;ProofWithPublicInputs&lt;F, C, D&gt;&gt;,\n    agg_root_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n    public_values: PublicValues,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;(ProofWithPublicInputs&lt;F, C, D&gt;, FinalPublicValues), <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Create a final block proof, once all transactions of a given block have\nbeen combined into a single aggregation proof.</p>\n<p>Block proofs can either be generated as standalone, or combined with a\nprevious block proof to assert validity of a range of blocks.</p>\n<h5 id=\"arguments-6\"><a class=\"doc-anchor\" href=\"#arguments-6\">§</a>Arguments</h5>\n<ul>\n<li><code>opt_parent_block_proof</code>: an optional parent block proof. Passing one\nwill generate a proof of validity for both the block range covered by\nthe previous proof and the current block.</li>\n<li><code>agg_root_proof</code>: the final aggregation proof containing all\ntransactions within the current block.</li>\n<li><code>public_values</code>: the public values associated to the aggregation\nproof.</li>\n</ul>\n<h5 id=\"outputs-3\"><a class=\"doc-anchor\" href=\"#outputs-3\">§</a>Outputs</h5>\n<p>This method outputs a tuple of [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>] and\nits [<code>PublicValues</code>]. Only the proof with public inputs is necessary\nfor a verifier to assert correctness of the computation.</p>\n</div></details><section id=\"method.verify_block\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">verify_block</a>(\n    &amp;self,\n    block_proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section><details class=\"toggle method-toggle\" open><summary><section id=\"method.prove_two_to_one_block\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">prove_two_to_one_block</a>(\n    &amp;self,\n    lhs: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n    lhs_is_agg: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n    rhs: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n    rhs_is_agg: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;ProofWithPublicInputs&lt;F, C, D&gt;, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Aggregates two proofs in manner similar to [<code>prove_aggregation</code>].</p>\n<h5 id=\"arguments-7\"><a class=\"doc-anchor\" href=\"#arguments-7\">§</a>Arguments</h5>\n<ul>\n<li><code>lhs</code>: a proof of either a block or previous aggregation.</li>\n<li><code>lhs_is_agg</code>: specify which case <code>lhs</code> was.</li>\n<li><code>rhs</code>: a proof of either a block or previous aggregation.</li>\n<li><code>rhs_is_agg</code>: specify which case <code>rhs</code> was.</li>\n</ul>\n<h5 id=\"outputs-4\"><a class=\"doc-anchor\" href=\"#outputs-4\">§</a>Outputs</h5>\n<p>Returns a [<code>ProofWithPublicInputs&lt;F, C, D&gt;</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.verify_two_to_one_block\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">verify_two_to_one_block</a>(\n    &amp;self,\n    proof: &amp;ProofWithPublicInputs&lt;F, C, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://docs.rs/anyhow/1.0.85/anyhow/struct.Error.html\" title=\"struct anyhow::Error\">Error</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Verifies an existing block aggregation proof.</p>\n<h5 id=\"arguments-8\"><a class=\"doc-anchor\" href=\"#arguments-8\">§</a>Arguments</h5>\n<ul>\n<li><code>proof</code>: The proof generated with <code>prove_two_to_one_block</code>.</li>\n</ul>\n<h5 id=\"outputs-5\"><a class=\"doc-anchor\" href=\"#outputs-5\">§</a>Outputs</h5>\n<p>Returns whether the proof was valid or not.</p>\n</div></details></div></details>",0,"proof_gen::types::AllRecursiveCircuits"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"impl\"><a href=\"#impl-Debug-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F, C, const D: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for AllRecursiveCircuits&lt;F, C, D&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + RichField + Extendable&lt;D&gt;,\n    C: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + GenericConfig&lt;D, F = F&gt;,\n    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","proof_gen::types::AllRecursiveCircuits"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"impl\"><a href=\"#impl-PartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F, C, const D: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a> for AllRecursiveCircuits&lt;F, C, D&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a> + RichField + Extendable&lt;D&gt;,\n    C: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a> + GenericConfig&lt;D, F = F&gt;,\n    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;AllRecursiveCircuits&lt;F, C, D&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#261\">source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq","proof_gen::types::AllRecursiveCircuits"],["<section id=\"impl-Eq-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"impl\"><a href=\"#impl-Eq-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F, C, const D: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> for AllRecursiveCircuits&lt;F, C, D&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + RichField + Extendable&lt;D&gt;,\n    C: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + GenericConfig&lt;D, F = F&gt;,\n    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section>","Eq","proof_gen::types::AllRecursiveCircuits"],["<section id=\"impl-StructuralPartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"impl\"><a href=\"#impl-StructuralPartialEq-for-AllRecursiveCircuits%3CF,+C,+D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;F, C, const D: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html\" title=\"trait core::marker::StructuralPartialEq\">StructuralPartialEq</a> for AllRecursiveCircuits&lt;F, C, D&gt;<div class=\"where\">where\n    F: RichField + Extendable&lt;D&gt;,\n    C: GenericConfig&lt;D, F = F&gt;,\n    &lt;C as GenericConfig&lt;D&gt;&gt;::Hasher: AlgebraicHasher&lt;F&gt;,</div></h3></section>","StructuralPartialEq","proof_gen::types::AllRecursiveCircuits"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[34527]}