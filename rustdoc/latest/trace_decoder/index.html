<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Your neighborhood zk-ready ethereum node emits binary “witnesses”."><title>trace_decoder - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="trace_decoder" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (1f12b9b0f 2024-08-27)" data-channel="nightly" data-search-js="search-acd2e111c9cb27e3.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
    integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
    integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            fleqn: false,
            macros: {
                "\\F": "\\mathbb{F}",
                "\\G": "\\mathbb{G}",
                "\\O": "\\mathcal{O}",
                "\\(": "\\left(",
                "\\)": "\\right)",
                "\\norm": "\\left\\vert #1 \\right\\vert",
                "\\set": "\\mathcal{ #1 }",
            },
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\(", right: "\\)", display: false },
                { left: "$", right: "$", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    });
</script>
</head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../trace_decoder/index.html">trace_<wbr>decoder</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">trace_decoder</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/trace_decoder/lib.rs.html#1-494">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><div class="warning">
This library is undergoing major refactoring as part of (#275)(https://github.com/0xPolygonZero/zk_evm/issues/275).
Consider all TODOs to be tracked under that issue.
</div>
<p>Your neighborhood zk-ready <a href="https://github.com/0xPolygonZero/erigon">ethereum</a>
<a href="https://github.com/0xPolygonHermez/cdk-erigon/">node</a> emits binary “witnesses”<sup id="fnref1"><a href="#fn1">1</a></sup>.</p>
<p>But [<code>plonky2</code>], your prover, wants [<code>GenerationInputs</code>].</p>
<p>This library helps you get there.</p>
<h2 id="non-goals"><a class="doc-anchor" href="#non-goals">§</a>Non-Goals</h2>
<ul>
<li>Performance - this won’t be the bottleneck in any proving system.</li>
<li>Robustness - malicious or malformed input may crash this library.</li>
</ul>
<p>TODO(0xaatif): https://github.com/0xPolygonZero/zk_evm/issues/275
refactor all the docs below</p>
<p>It might not be obvious why we need traces for each txn in order to generate
proofs. While it’s true that we could just run all the txns of a block in an
EVM to generate the traces ourselves, there are a few major downsides:</p>
<ul>
<li>The client is likely a full node and already has to run the txns in an EVM
anyways.</li>
<li>We want this protocol to be as agnostic as possible to the underlying
chain that we’re generating proofs for, and running our own EVM would
likely cause us to loose this genericness.</li>
</ul>
<p>While it’s also true that we run our own zk-EVM (plonky2) to generate
proofs, it’s critical that we are able to generate txn proofs in parallel.
Since generating proofs with plonky2 is very slow, this would force us to
sequentialize the entire proof generation process. So in the end, it’s ideal
if we can get this information sent to us instead.</p>
<p>This library generates an Intermediary Representation (IR) of
a block’s transactions, given a <a href="struct.BlockTrace.html" title="struct trace_decoder::BlockTrace">BlockTrace</a> and some additional
data represented by <a href="struct.OtherBlockData.html" title="struct trace_decoder::OtherBlockData">OtherBlockData</a>.</p>
<p>It first preprocesses the <a href="struct.BlockTrace.html" title="struct trace_decoder::BlockTrace">BlockTrace</a> to provide transaction,
withdrawals and tries data that can be directly used to generate an IR.
For each transaction, this library extracts the
necessary data from the processed transaction information to
return the IR.</p>
<p>The IR is used to generate root proofs, then aggregation proofs and finally
block proofs. Because aggregation proofs require at least two entries, we
pad the vector of IRs thanks to additional dummy payload intermediary
representations whenever necessary.</p>
<h4 id="withdrawals-and-padding"><a class="doc-anchor" href="#withdrawals-and-padding">§</a><a href="https://ethereum.org/staking/withdrawals">Withdrawals</a> and Padding</h4>
<p>Withdrawals are all proven together in a dummy payload. A dummy payload
corresponds to the IR of a proof with no transaction. They must, however, be
proven last. The padding is therefore carried out as follows: If there are
no transactions in the block, we add two dummy transactions. The withdrawals
– if any – are added to the second dummy transaction. If there is only one
transaction in the block, we add one dummy transaction. If
there are withdrawals, the dummy transaction is at the end. Otherwise, it is
added at the start. If there are two or more transactions:</p>
<ul>
<li>if there are no withdrawals, no dummy transactions are added</li>
<li>if there are withdrawals, one dummy transaction is added at the end, with
all the withdrawals in it.</li>
</ul>
<div class="footnotes"><hr><ol><li id="fn1"><p>A witness is an attestation of the state of the world, which can be
proven by a prover.&nbsp;<a href="#fnref1">↩</a></p></li></ol></div></div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BlockLevelData.html" title="struct trace_decoder::BlockLevelData">Block<wbr>Level<wbr>Data</a></div><div class="desc docblock-short">Data that is specific to a block and is constant for all txns in a given
block.</div></li><li><div class="item-name"><a class="struct" href="struct.BlockTrace.html" title="struct trace_decoder::BlockTrace">Block<wbr>Trace</a></div><div class="desc docblock-short">Core payload needed to generate proof for a block.
Additional data retrievable from the blockchain node (using standard ETH RPC
API) may be needed for proof generation.</div></li><li><div class="item-name"><a class="struct" href="struct.CombinedPreImages.html" title="struct trace_decoder::CombinedPreImages">Combined<wbr>PreImages</a></div><div class="desc docblock-short">A trie pre-image where both state &amp; storage are combined into one payload.</div></li><li><div class="item-name"><a class="struct" href="struct.OtherBlockData.html" title="struct trace_decoder::OtherBlockData">Other<wbr>Block<wbr>Data</a></div><div class="desc docblock-short">Other data that is needed for proof gen.</div></li><li><div class="item-name"><a class="struct" href="struct.SeparateTriePreImages.html" title="struct trace_decoder::SeparateTriePreImages">Separate<wbr>Trie<wbr>PreImages</a></div><div class="desc docblock-short">State/Storage trie pre-images that are separate.</div></li><li><div class="item-name"><a class="struct" href="struct.TxnInfo.html" title="struct trace_decoder::TxnInfo">TxnInfo</a></div><div class="desc docblock-short">Info specific to txns in the block.</div></li><li><div class="item-name"><a class="struct" href="struct.TxnMeta.html" title="struct trace_decoder::TxnMeta">TxnMeta</a></div><div class="desc docblock-short">Structure holding metadata for one transaction.</div></li><li><div class="item-name"><a class="struct" href="struct.TxnTrace.html" title="struct trace_decoder::TxnTrace">TxnTrace</a></div><div class="desc docblock-short">A “trace” specific to an account for a txn.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.BlockTraceTriePreImages.html" title="enum trace_decoder::BlockTraceTriePreImages">Block<wbr>Trace<wbr>Trie<wbr>PreImages</a></div><div class="desc docblock-short">Minimal hashed out tries needed by all txns in the block.</div></li><li><div class="item-name"><a class="enum" href="enum.ContractCodeUsage.html" title="enum trace_decoder::ContractCodeUsage">Contract<wbr>Code<wbr>Usage</a></div><div class="desc docblock-short">Contract code access type. Used by txn traces.</div></li><li><div class="item-name"><a class="enum" href="enum.SeparateStorageTriesPreImage.html" title="enum trace_decoder::SeparateStorageTriesPreImage">Separate<wbr>Storage<wbr>Tries<wbr>PreImage</a></div><div class="desc docblock-short">A trie pre-image where state and storage are separate.</div></li><li><div class="item-name"><a class="enum" href="enum.SeparateTriePreImage.html" title="enum trace_decoder::SeparateTriePreImage">Separate<wbr>Trie<wbr>PreImage</a></div><div class="desc docblock-short">A trie pre-image where state &amp; storage are separate.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.entrypoint.html" title="fn trace_decoder::entrypoint">entrypoint</a></div><div class="desc docblock-short">TODO(0xaatif): <a href="https://github.com/0xPolygonZero/zk_evm/issues/275">https://github.com/0xPolygonZero/zk_evm/issues/275</a>
document this once we have the API finalized</div></li></ul></section></div></main></body></html>